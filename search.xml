<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于本博客</title>
    <url>/2023/10/17/%E5%85%B3%E4%BA%8E%E6%9C%AC%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="关于这个个人博客"><a href="#关于这个个人博客" class="headerlink" title="关于这个个人博客"></a>关于这个个人博客</h1><h2 id="项目简介："><a href="#项目简介：" class="headerlink" title="项目简介："></a>项目简介：</h2><ul>
<li>新学期到来，一方面朋友搞了个个人博客我觉得蛮帅的，另一方面在github上被薄纱的时候发现大佬们很多喜欢建一个自己的博客用来记录自己的笔记和分享，因此在朋友的帮助下基于Hexo框架和Hexo的Next主题搭建了本网站，并且将其部署至github，用作自己的笔记，以后会在本网站更新自己的学习笔记。</li>
</ul>
<hr>
<h2 id="项目部署指南："><a href="#项目部署指南：" class="headerlink" title="项目部署指南："></a>项目部署指南：</h2><ul>
<li><p>首先先感谢@<a href="https://kalipolis.gitee.io/">kalipolis</a>提供的bilibili教程链接： <a href="https://www.bilibili.com/video/BV1ts4y1f7Gu/">https://www.bilibili.com/video/BV1ts4y1f7Gu/</a></p>
</li>
<li><p>其次感谢以下部署Next主题所用到的教程：</p>
<p><a href="https://zhuanlan.zhihu.com/p/618864711">Hexo+Next主题搭建个人博客+优化全过程（完整详细版） - 知乎 (zhihu.com)</a></p>
<p><a href="https://www.bilibili.com/video/BV16W411t7mq">https://www.bilibili.com/video/BV16W411t7mq</a></p>
</li>
<li><p>gitee的部署可以看第一个b站视频，对于github的部署可以看第二个，第三个视频为对于next主题的具体运用，在项目中，需要用到markdown语法来编写文章的内容，我用的是Typora,一个markdown记笔记的软件来进行文章的编辑，同样使用Typora的朋友可以参考<a href="https://zhuanlan.zhihu.com/p/293557841">知乎教程</a>进行基础的学习，更进一步可以翻阅菜鸟教程或者markdown的官方文档，在此不多赘述了。</p>
</li>
<li><p>除了next主题之外，还有很多其他主题，可以在官网进行下载安装，按照各个主题的官方文档进行相应配置，如果说你对网页的了解不是很多，仅仅是想搞着玩，那么建议安装文档详细的主题。</p>
<hr>
<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><ul>
<li>这篇关于博客的声明会随着网站的更新随时补充，希望我别当懒狗。。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title>关于github项目蔚蓝手感2d控制器的研究</title>
    <url>/2023/10/18/%E5%85%B3%E4%BA%8Egithub%E9%A1%B9%E7%9B%AE%E8%94%9A%E8%93%9D%E6%89%8B%E6%84%9F2d%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="蔚蓝手感项目研究："><a href="#蔚蓝手感项目研究：" class="headerlink" title="蔚蓝手感项目研究："></a>蔚蓝手感项目研究：</h2><h3 id="项目链接："><a href="#项目链接：" class="headerlink" title="项目链接："></a>项目链接：</h3><p><a href="https://github.com/david-reborn/2D-Platform-Controller">https://github.com/david-reborn/2D-Platform-Controller</a></p>
<span id="more"></span>

<h3 id="脚本分析："><a href="#脚本分析：" class="headerlink" title="脚本分析："></a>脚本分析：</h3><h4 id="common文件夹："><a href="#common文件夹：" class="headerlink" title="common文件夹："></a>common文件夹：</h4><h5 id="Calc脚本"><a href="#Calc脚本" class="headerlink" title="Calc脚本"></a>Calc脚本</h5><ul>
<li>提供一个方法，这个方法接受三个浮点型参数：<code>val</code>（值）、prevVal（前一个值）和<code>interval</code>（间隔），用于确定当前值<code>val</code>相对于前一个值<code>prevVal</code>是否进入了新的<code>interval</code>区间。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Myd.Common</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Calc</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">OnInterval</span>(<span class="params"><span class="built_in">float</span> val, <span class="built_in">float</span> prevVal, <span class="built_in">float</span> interval</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">int</span>)(prevVal / interval) != (<span class="built_in">int</span>)(val / interval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   具体实现上，这个方法首先分别计算<code>prevVal</code>和<code>val</code>除以<code>interval</code>的结果的整数部分，然后比较这两个结果是否相等。如果不等，表示<code>val</code>已经“跨越”了一个或多个<code>interval</code>，相当于进入了新的区间，方法返回<code>true</code>；如果相等，表示<code>val</code>仍处于<code>prevVal</code>所在的<code>interval</code>区间内，方法返回<code>false</code>。</p>
<h5 id="Ease脚本"><a href="#Ease脚本" class="headerlink" title="Ease脚本"></a>Ease脚本</h5><ul>
<li><p>定义类Ease这个静态类，这个<code>Ease</code>类定义了许多常见的缓动函数，其中包括线性（<code>Linear</code>）、正弦（<code>SineIn, SineOut, SineInOut</code>）、二次（<code>QuadIn, QuadOut, QuadInOut</code>）、三次（<code>CubeIn, CubeOut, CubeInOut</code>），四次方（<code>QuintIn, QuintOut, QuintInOut</code>）、指数（<code>ExpoIn, ExpoOut, ExpoInOut</code>）等等。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">float</span> <span class="title">Easer</span>(<span class="params"><span class="built_in">float</span> t</span>)</span>;</span><br></pre></td></tr></table></figure>


</li>
<li><p>此外，这个类还定义了一个委托<code>Easer</code>，它接受一个<code>float</code>类型的参数，并返回一个<code>float</code>类型的值。所有的缓动函数都是这个类型的，接收一个在0至1之间的浮点数，表示开始和结束之间的一个插值，然后返回一个可能略大于或小于这个范围的新的浮点数。</p>
</li>
</ul>
<p>剩下的common文件夹中的脚本在项目中没有引用，因此不再解释</p>
<hr>
<h4 id="Components文件夹"><a href="#Components文件夹" class="headerlink" title="Components文件夹"></a>Components文件夹</h4><h5 id="JumpCheck脚本"><a href="#JumpCheck脚本" class="headerlink" title="JumpCheck脚本"></a>JumpCheck脚本</h5><ul>
<li>专门控制土狼时间的类，来控制是否能够跳跃。</li>
</ul>
<h5 id="WallBoost"><a href="#WallBoost" class="headerlink" title="WallBoost"></a>WallBoost</h5><ul>
<li>Wall Boost组件，当攀墙时跳跃，如果没有指定X轴方向，则系统自动产生一个推离墙面的力。且给予一定的持续时间。</li>
</ul>
<h4 id="Configs"><a href="#Configs" class="headerlink" title="Configs"></a>Configs</h4><h5 id="PlayerParams"><a href="#PlayerParams" class="headerlink" title="PlayerParams"></a>PlayerParams</h5><ul>
<li>存放Player的参数，是个SO，包含了重载常数的方法和回调的委托</li>
</ul>
<hr>
<h4 id="Core文件夹"><a href="#Core文件夹" class="headerlink" title="Core文件夹"></a>Core文件夹</h4><h5 id="States"><a href="#States" class="headerlink" title="States"></a>States</h5><h6 id="FiniteStateMachine"><a href="#FiniteStateMachine" class="headerlink" title="FiniteStateMachine"></a>FiniteStateMachine</h6><ul>
<li><p>定义了状态机的基础状态 抽象类BaseActionState，有限状态机FiniteStateMachine以及状态的枚举类EActionState.</p>
</li>
<li><pre><code class="c#">public abstract class BaseActionState
    &#123;
        protected EActionState state;
        protected PlayerController ctx;

        protected BaseActionState(EActionState state, PlayerController context)
        &#123;
            this.state = state;
            this.ctx = context;
        &#125;

        public EActionState State &#123; get =&gt; state; &#125;

        //每一帧都执行的逻辑
        public abstract EActionState Update(float deltaTime);

        public abstract IEnumerator Coroutine();

        public abstract void OnBegin();

        public abstract void OnEnd();

        public abstract bool IsCoroutine();
    &#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  在这一段代码中，定义了各个状态的基类，主要关注几个方法的定义</span><br><span class="line"></span><br><span class="line">+ 有限状态机类：</span><br><span class="line"></span><br><span class="line">+  属性声明</span><br><span class="line"></span><br><span class="line">  ```c#</span><br><span class="line">  	    private S[] states;</span><br><span class="line">  		private int currState = -1;</span><br><span class="line">          private int prevState = -1;</span><br><span class="line">          private Coroutine currentCoroutine;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>构造函数：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FiniteStateMachine</span>(<span class="params"><span class="built_in">int</span> size</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.states = <span class="keyword">new</span> S[size];</span><br><span class="line">            <span class="keyword">this</span>.currentCoroutine = <span class="keyword">new</span> Coroutine(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Update</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"><span class="built_in">float</span> deltaTime</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            State = (<span class="built_in">int</span>)<span class="keyword">this</span>.states[<span class="keyword">this</span>.currState].Update(deltaTime);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.currentCoroutine.Active)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.currentCoroutine.Update(deltaTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>TODO:其他状态</p>
</li>
</ul>
<h5 id="其他核心控件："><a href="#其他核心控件：" class="headerlink" title="其他核心控件："></a>其他核心控件：</h5><ul>
<li>一些解耦用的接口，相应的状态，管理状态的playerController,这边用partical class实现了对playcontroller中控制不同部分的部件的解耦</li>
</ul>
<hr>
<h4 id="Effect文件夹"><a href="#Effect文件夹" class="headerlink" title="Effect文件夹"></a>Effect文件夹</h4><h5 id="EffectComponent"><a href="#EffectComponent" class="headerlink" title="EffectComponent:"></a>EffectComponent:</h5><ul>
<li>挂载在playerRender的预制体上，控制人物的头巾效果</li>
</ul>
<h5 id="SceneEffectManager"><a href="#SceneEffectManager" class="headerlink" title="SceneEffectManager"></a>SceneEffectManager</h5><ul>
<li><p>管理所有的特效，具体特效如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">        <span class="keyword">private</span> ParticleSystem vfxMoveDust;</span><br><span class="line">        [<span class="meta">SerializeField</span>]</span><br><span class="line">        <span class="keyword">private</span> ParticleSystem vfxJumpDust;</span><br><span class="line">        [<span class="meta">SerializeField</span>]</span><br><span class="line">        <span class="keyword">private</span> ParticleSystem vfxLandDust;</span><br><span class="line">        [<span class="meta">SerializeField</span>]</span><br><span class="line">        <span class="keyword">private</span> ParticleSystem vfxDashLine;</span><br><span class="line">        [<span class="meta">SerializeField</span>]</span><br><span class="line">        <span class="keyword">private</span> RippleEffect vfxRippleEffect;</span><br><span class="line">        [<span class="meta">SerializeField</span>]</span><br><span class="line">        <span class="keyword">private</span> GameObject vfxSpeedRing;</span><br></pre></td></tr></table></figure>

<p>在该脚本中，提供了为上层开启特效的函数api</p>
</li>
</ul>
<h5 id="TrailSnapShot"><a href="#TrailSnapShot" class="headerlink" title="TrailSnapShot"></a>TrailSnapShot</h5><ul>
<li>断裂特效？</li>
</ul>
<hr>
<h4 id="Level文件夹"><a href="#Level文件夹" class="headerlink" title="Level文件夹"></a>Level文件夹</h4><p>该文件夹中的Gound和Level只提供了自己颜色的接口,也就是让玩家获取到地图的颜色</p>
<hr>
<h4 id="Postprocessing文件夹"><a href="#Postprocessing文件夹" class="headerlink" title="Postprocessing文件夹"></a>Postprocessing文件夹</h4><h5 id="PostEffectsController"><a href="#PostEffectsController" class="headerlink" title="PostEffectsController:"></a>PostEffectsController:</h5><ul>
<li>管理对于摄像机的特殊效果，也就是冲刺时的空间扭曲</li>
</ul>
<h5 id="RippleEffect"><a href="#RippleEffect" class="headerlink" title="RippleEffect"></a>RippleEffect</h5><ul>
<li>对于效果的具体实现（通过shader实现）</li>
</ul>
<h4 id="其他重要脚本"><a href="#其他重要脚本" class="headerlink" title="其他重要脚本"></a>其他重要脚本</h4><h5 id="Constant："><a href="#Constant：" class="headerlink" title="Constant："></a>Constant：</h5><ul>
<li>一些游戏中的常数</li>
</ul>
<h5 id="GameInput"><a href="#GameInput" class="headerlink" title="GameInput:"></a>GameInput:</h5><ul>
<li>管理游戏的输入（包括一些预输入的功能）</li>
</ul>
<h4 id="Player："><a href="#Player：" class="headerlink" title="Player："></a>Player：</h4><ul>
<li>管理playercontroller和playerRenderer，并且允许内部进行交互</li>
</ul>
<h5 id="PlayerRender"><a href="#PlayerRender" class="headerlink" title="PlayerRender"></a>PlayerRender</h5><ul>
<li>绘制玩家的形象，以下是其中的属性</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">        <span class="keyword">public</span> SpriteRenderer spriteRenderer;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">SerializeField</span>]</span><br><span class="line">        <span class="keyword">public</span> ParticleSystem vfxDashFlux;</span><br><span class="line">        [<span class="meta">SerializeField</span>]</span><br><span class="line">        <span class="keyword">public</span> ParticleSystem vfxWallSlide;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">SerializeField</span>]</span><br><span class="line">        <span class="keyword">public</span> TrailRenderer hair;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">SerializeField</span>]</span><br><span class="line">        <span class="keyword">public</span> SpriteRenderer hairSprite01;</span><br><span class="line">        [<span class="meta">SerializeField</span>]</span><br><span class="line">        <span class="keyword">public</span> SpriteRenderer hairSprite02;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Vector2 scale;</span><br><span class="line">        <span class="keyword">private</span> Vector2 currSpriteScale;</span><br></pre></td></tr></table></figure>

<h5 id="SceneCamera"><a href="#SceneCamera" class="headerlink" title="SceneCamera:"></a>SceneCamera:</h5><p>实现摄像头的抖动等功能，实际上可用cinemachine的虚拟摄像机的功能代替</p>
<h5 id="Game"><a href="#Game" class="headerlink" title="Game:"></a>Game:</h5><p>最高层的脚本，管控整个游戏的流程，并且负责提供一些API供低层的脚本使用</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>ai研究概述</title>
    <url>/2024/05/03/ai%E7%A0%94%E7%A9%B6%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://design.jskyzero.com/2023/10/10/sekiro_lion_tamarin_AI/">AI反拆：只狼狮子猿 | 设计者笔记 (jskyzero.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/614731111">如何设计有“对话感”的BOSS？《只狼》Ai完全拆解。 - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/jk_chen_acmer/article/details/118894596">HTN框架介绍、开发心得-CSDN博客</a></p>
<p><a href="https://www.gameres.com/830335.html">游戏AI研究（一）：感知AI - GameRes游资网</a></p>
<p><a href="https://blog.csdn.net/qq_39885372/article/details/103950973">FSM（状态机）、HFSM（分层状态机）、BT（行为树）的区别_对战状态机-CSDN博客</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/463182588">行为树入门教程 - 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/675093070">游戏开发技术杂谈14：理解行为树 - 知乎 (zhihu.com)</a></p>
<p><a href="https://robohub.org/introduction-to-behavior-trees/">https://robohub.org/introduction-to-behavior-trees/</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/463182588">https://zhuanlan.zhihu.com/p/463182588</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/611393851">行为树的理论与实践入门 - 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/575072589">GOAP思路解析与代码框架 - 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/372718085">&lt;游戏开发&gt;怪物AI实现方案-GOAP - 知乎 (zhihu.com)</a></p>
<p><a href="https://www.lfzxb.top/goal-oriented-action-planning-tech-share/">目标导向的AI系统（GOAP）技术分享 | 登峰造极者，殊途亦同归。 (lfzxb.top)</a></p>
<p><a href="https://github.com/AkiKurisu/AkiGOAP">AkiKurisu&#x2F;AkiGOAP: Modular and high-performed Unity Goal Oriented Action Planner with well designed visual graph editor (github.com)</a></p>
<p><a href="https://developer.unity.cn/projects/657fcd52edbc2a002654a6b4">游戏AI行为决策方法——HTN 教程（附代码与项目） - 技术专栏 - Unity官方开发者社区</a></p>
<p><a href="https://yimicgh.top/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/AI-Plan-11-Task-Networks/">Ai Plan (11) Task Network | Yimi的小天地 (yimicgh.top)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/597082052">AI算法–通过实例探讨分层任务网络规划(HTN) - 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/607593872">HTN简略笔记 - 知乎 (zhihu.com)</a></p>
<span id="more"></span>

<h2 id="概要："><a href="#概要：" class="headerlink" title="概要："></a>概要：</h2><h3 id="游戏AI是什么？"><a href="#游戏AI是什么？" class="headerlink" title="游戏AI是什么？"></a>游戏AI是什么？</h3><p>在以前游戏AI基本上都是程序员预先定义编写好可能发生的行为，而不具有机器学习那种自我学习的特性。这是因为游戏AI主要职责是模拟出智能行为，而并非学习（例如：街道上会避让车的人群，天空中乱飞的小鸟，来回巡逻的守卫，兵线上的小兵…）。而游戏AI往往使用的是以行为树为代表的人工设计方法，而很少应用到机器学习技术。可以说游戏AI是智能的假象。</p>
<p>在游戏中，AI（人工智能）是指模拟和实现游戏角色的智能行为的技术。虽然在过去，游戏AI主要依赖程序员预定义可能发生的行为，但随着技术的发展，现代游戏AI已经涵盖了更多复杂的技术和方法。以下是一些常见的游戏AI架构：</p>
<ol>
<li><strong>行为树（Behavior Trees）</strong>：行为树是一种流行的游戏AI设计方法，它将角色的行为表示为树结构。游戏开发者可以通过安排节点和连接来控制角色的决策和行为。</li>
<li><strong>状态机（Finite State Machines）</strong>：状态机是一种基本的游戏AI架构，角色可以处于不同的状态，并根据条件或事件转换状态。</li>
<li><strong>路径规划（Pathfinding Algorithms）</strong>：路径规划是指让角色在游戏中找到最佳路径的技术。常见的算法包括A*算法和Dijkstra算法。</li>
<li><strong>博弈树（Minimax Algorithm）</strong>：在许多游戏中，特别是棋类游戏，博弈树是一种用于决策制定的重要技术，通过搜索可能的走法并选择最有利的策略。</li>
<li><strong>机器学习（Machine Learning）</strong>：现代游戏开始采用机器学习技术来改进游戏AI的表现。深度强化学习等技术被应用于让AI角色更加智能和自适应。</li>
</ol>
<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>状态机模式是一个游戏常用的经典设计模式，常被用作管理一种物体的各种状态（例如管理人物的行走，站立，跳跃等状态）</p>
<p>游戏 AI 选择状态机模式的原因有几个重要的考虑：</p>
<ol>
<li><strong>简单性和可维护性</strong>：状态机模式非常直观和易于理解。通过将行为划分为不同的状态，并定义状态之间的转换规则，使得代码更易维护和扩展。开发人员可以直观地查看状态之间的转换关系，从而更容易调试和修改行为。</li>
<li><strong>灵活性</strong>：状态机模式提供了对游戏 AI 行为进行动态管理和调整的灵活性。通过修改状态之间的转换规则，可以改变 AI 的行为方式，使得游戏 AI 可以根据不同的情况作出不同的反应。</li>
<li><strong>逻辑分离</strong>：使用状态机模式可以将游戏 AI 的逻辑和状态信息进行分离。这样可以使得 AI 的行为更具可读性，并允许开发人员单独处理状态转换逻辑和状态具体行为逻辑，提高了代码的组织和可维护性。</li>
<li><strong>适用性广泛</strong>：状态机模式适用于各种不同类型的游戏 AI，无论是简单的角色移动AI还是复杂的决策系统。状态机模式是一种通用且有效的设计模式，适用于各种游戏 AI 场景。</li>
</ol>
<h3 id="为什么需要状态机？"><a href="#为什么需要状态机？" class="headerlink" title="为什么需要状态机？"></a>为什么需要状态机？</h3><p>假如我们正在开发一款动作游戏，当前的任务是实现根据输入来控制主角的行为——当按下B键时，他应该跳跃。</p>
<p>直观的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (input == PRESS_B) &#123;</span><br><span class="line">     <span class="keyword">if</span> (!m_isJumping) &#123;</span><br><span class="line">         m_isJumping = <span class="literal">true</span>;</span><br><span class="line">         <span class="built_in">Jump</span>();<span class="comment">//跳跃的代码</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>后来我们需要添加更多行为了，所有行为如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (input == PRESS_B) &#123;</span><br><span class="line">       <span class="comment">//如果在站立时且没在跳跃，则跳跃</span></span><br><span class="line">       <span class="keyword">if</span> (!m_isJumping &amp;&amp; m_isStanding) &#123;</span><br><span class="line">           m_isJumping = <span class="literal">true</span>;</span><br><span class="line">           player.<span class="built_in">jump</span>();<span class="comment">//跳跃的代码</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (input == PRESS_DOWN) &#123;</span><br><span class="line">       <span class="comment">//如果在跳跃时且没在俯冲，则俯冲</span></span><br><span class="line">       <span class="keyword">if</span> (m_isJumping &amp;&amp; !m_isDiving) &#123;</span><br><span class="line">           m_isDiving</span><br><span class="line">           player.<span class="built_in">dive</span>();<span class="comment">//俯冲的代码</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果没在跳跃</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (!m_isJumping) &#123;</span><br><span class="line">           <span class="comment">//如果站立时，则蹲下</span></span><br><span class="line">           <span class="keyword">if</span> (m_isStanding) &#123;</span><br><span class="line">               m_isStanding = <span class="literal">false</span>;</span><br><span class="line">               player.<span class="built_in">sneak</span>();<span class="comment">//蹲下的代码</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果蹲下时，则站立</span></span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               m_isStanding = <span class="literal">true</span>;</span><br><span class="line">               player.<span class="built_in">stand</span>();<span class="comment">//站立的代码</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到一堆if-else语句非常复杂，要是添加更多行为，其逻辑结构更加难以维护，而且主角的代码又得重新编译（耦合性大）</p>
<p>一个可行的办法是将这些 <strong>状态&amp;状态切换&amp;状态对应的行为</strong> 封装成类，</p>
<p><img src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/1409576-20181226091322393-1146430295.png" alt="img"></p>
<p>代码实现1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//状态接口类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//处理输入，然后根据输入转换相应的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleInput</span><span class="params">(Player&amp; player,<span class="type">const</span> Input&amp; input)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//站立状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StandState</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleInput</span><span class="params">(Player&amp; player, <span class="type">const</span> Input&amp; input)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input == PRESS_B) &#123;</span><br><span class="line">            player.<span class="built_in">jump</span>();<span class="comment">//角色跳跃的代码</span></span><br><span class="line">            player.<span class="built_in">setState</span>(<span class="built_in">JumpState</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (input == PRESS_DOWN) &#123;</span><br><span class="line">            player.<span class="built_in">sneak</span>();<span class="comment">//角色蹲下的代码</span></span><br><span class="line">            player.<span class="built_in">setState</span>(<span class="built_in">SneakState</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//跳跃状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JumpState</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleInput</span><span class="params">(Player&amp; player, <span class="type">const</span> Input&amp; input)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input == PRESS_DOWN) &#123;</span><br><span class="line">            player.<span class="built_in">dive</span>();<span class="comment">//角色俯冲的代码</span></span><br><span class="line">            player.<span class="built_in">setState</span>(<span class="built_in">DiveState</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//下蹲状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SneakState</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleInput</span><span class="params">(Player&amp; player, <span class="type">const</span> Input&amp; input)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input == PRESS_DOWN) &#123;</span><br><span class="line">            player.<span class="built_in">stand</span>();<span class="comment">//角色站立的代码</span></span><br><span class="line">            player.<span class="built_in">setState</span>(<span class="built_in">StandState</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//俯冲状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DiveState</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleInput</span><span class="params">(Player&amp; player, <span class="type">const</span> Input&amp; input)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码实现2：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="built_in">enum</span> GameState</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//游戏开始</span></span><br><span class="line">    GameStart,</span><br><span class="line">    Preparation,</span><br><span class="line">    <span class="comment">//玩家回合</span></span><br><span class="line">    PlayerRoundStartResolution,</span><br><span class="line">    PlayerAction,</span><br><span class="line">    PlayerRoundEndResolution,</span><br><span class="line">    <span class="comment">//敌人回合</span></span><br><span class="line">    EnemyRoundStartResolution,</span><br><span class="line">    EnemyAction,</span><br><span class="line">    EnemyRoundEndResolution,</span><br><span class="line">    <span class="comment">//战斗结束</span></span><br><span class="line">    PlayerLose,</span><br><span class="line">    PlayerLoseResolution,</span><br><span class="line">    PlayerWin,</span><br><span class="line">    Reward</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEnter</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unity的动画状态机就是一个很好的例子</p>
<p><img src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/1409576-20190207223240946-913199845.jpg" alt="img"></p>
<h2 id="行为树"><a href="#行为树" class="headerlink" title="行为树"></a>行为树</h2><h3 id="为什么需要行为树？"><a href="#为什么需要行为树？" class="headerlink" title="为什么需要行为树？"></a>为什么需要行为树？</h3><ol>
<li><p><strong>层次化结构</strong>：行为树以树形结构组织 AI 的行为，具有层次化的特点，从顶部的根节点开始，逐级展开到叶子节点。这种结构使得行为树更容易理解和管理，能够清晰地表达 AI 的行为逻辑。</p>
</li>
<li><p><strong>灵活性</strong>：行为树提供了更灵活的行为组合方式，通过组合不同类型的节点（例如序列节点、选择节点、并行节点等），可以实现丰富多样的行为表达。这种灵活性使得行为树适用于各种复杂的 AI 行为设计需求。</p>
</li>
<li><p><strong>可扩展性</strong>：行为树易于扩展和调整。开发人员可以轻松地添加、修改或删除行为树的节点，而不会影响到其他部分的逻辑。这种特性使得行为树在面对复杂的 AI 行为需求时更加适用。</p>
<p><img src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/20190723100031475.png" alt="Unity战斗框架 优化Animator动画状态机排线_战斗动画状态机-CSDN博客"></p>
</li>
</ol>
<p>相较于状态机，行为树在复杂的 AI 行为设计上具有更多的优势，尤其适用于需要灵活、层次化、可扩展和容错的 AI 行为模型。</p>
<p>行为树是当前最主流的游戏开发中的AI实现方案，和状态机这样概念结构比较简单的模型不同，行为树自带了很多专属于行为树的概念，比如组合、装饰器、任务等。</p>
<h3 id="行为树的推导方法论"><a href="#行为树的推导方法论" class="headerlink" title="行为树的推导方法论"></a>行为树的推导方法论</h3><p><a href="https://zhuanlan.zhihu.com/p/675093070">游戏开发技术杂谈14：理解行为树 - 知乎 (zhihu.com)</a></p>
<p>简而言之，在游戏开发中使用行为树其实就是通过提供一个合理的逻辑表达方式来帮助策划，使得策划可以完全独立于程序进行配置</p>
<h3 id="行为树的概念（behavior-tree）"><a href="#行为树的概念（behavior-tree）" class="headerlink" title="行为树的概念（behavior tree）"></a>行为树的概念（behavior tree）</h3><ol>
<li><strong>行为树是树：</strong>执行时从根结点开始按照指定的顺序遍历，直到到达终结状态</li>
<li>**叶子结点都是可执行的行为:**叶子结点会进行具体的操作，可以是一个简单的检测操作，也可以是一个更复杂的操作，结点会返回状态信息(成功，失败，运行中)。</li>
<li><strong>内部结点控制树的遍历：</strong>内部结点会根据孩子结点返回的状态信息，按照特定的规则确定下一个执行的结点。</li>
</ol>
<p><img src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/image.png" alt="img"></p>
<ol>
<li>tick:行为树从根节点开始按照预定义的顺序遍历各个节点并执行他们的行为的过程称为一次tick，会返回**成功(success)<strong>，</strong>失败(failure)<strong>，</strong>运行中(running)**的状态信息给它的父结点。</li>
<li><strong>行为结点(execution node)<strong>：行为树的叶子结点，可以是动作结点(action node)或条件结点(condition node)。对于条件结点(condition node)会在一次tick后立马返回</strong>成功或</strong>失败的状态信息。对于动作结点(action node)则可以跨越多个tick执行，直到到达它的终结状态。一般来说，条件结点用于简单的判断(比如钳子是否打开?)，动作结点用于表示复杂的行为(比如打开房门)。</li>
<li><strong>控制结点(<strong><strong>control node</strong></strong>)：</strong>控制结点是行为树的内部结点，它们定义了遍历其孩子结点的方式。<strong>控制结点的孩子可以是行为结点，也可以是控制结点</strong>。<strong>顺序(Sequence)<strong>，</strong>备选(Fallback)<strong>，</strong>并行(Parallel)这3种类型的控制结点可以有任意数量的孩子结点<strong><strong>，它们的区别在于对其孩子结点的处理方式。而</strong></strong>装饰(Decorator)结点只能有一个孩子结点</strong>，用来对孩子结点的行为进行自定义修改。</li>
</ol>
<h3 id="不同类型的控制结点："><a href="#不同类型的控制结点：" class="headerlink" title="不同类型的控制结点："></a>不同类型的控制结点：</h3><h4 id="顺序节点"><a href="#顺序节点" class="headerlink" title="顺序节点"></a>顺序节点</h4><p>按顺序执行孩子结点直到其中一个孩子结点返回失败状态或所有孩子结点返回成功状态。</p>
<p><img src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/image.png"></p>
<h4 id="选择节点"><a href="#选择节点" class="headerlink" title="选择节点"></a>选择节点</h4><p>按顺序执行孩子结点直到其中一个孩子结点返回成功状态或所有孩子结点返回失败状态。一般用来实现角色的选择行为。</p>
<p><img src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/bt_fallback_node.png"></p>
<h4 id="并行节点"><a href="#并行节点" class="headerlink" title="并行节点"></a>并行节点</h4><p>“并行执行”所有孩子结点。直到至少M个孩子(M的值在1到N之间)结点返回成功状态或所有孩子结点返回失败状态。</p>
<p><img src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/1.png"></p>
<h4 id="装饰结点"><a href="#装饰结点" class="headerlink" title="装饰结点"></a>装饰结点</h4><p>装饰结点：以自定义的方式修改孩子结点的行为。比如Invert类型的装饰结点，可以反转其孩子结点返回的状态信息。为了方便他人理解，应该尽可能使用比较常见的装饰结点。</p>
<p><img src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/2.png"></p>
<h3 id="行为树举例说明"><a href="#行为树举例说明" class="headerlink" title="行为树举例说明"></a>行为树举例说明</h3><p>有一个角色的行为树，</p>
<p>当它周围没有敌人时，保持巡逻状态；</p>
<p>当它周围有敌人时，前往敌人的位置；</p>
<p>当它靠近敌人，达到攻击的范围时，执行攻击操作；</p>
<p>当敌人被消灭时，周围没有敌人了，回到之前的巡逻状态。</p>
<p><img src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/v2-a800c1c10fe5e8f13db4ad82f6d126f4_720w.webp" alt="img"></p>
<p><strong>行为节点（Action）</strong></p>
<p><img src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/v2-541de51410a1c5b8983a2eef32dbedf7_r.jpg" alt="img"></p>
<p>没有子节点，用以执行具体行为的节点。</p>
<p><strong>条件节点（Conditional）</strong></p>
<p><img src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/v2-4e0c131189696544271fda087c56ea2b_720w.webp" alt="img"></p>
<p>没有子节点，用以判定条件是否成立的节点。</p>
<h3 id="在unity中使用行为树插件："><a href="#在unity中使用行为树插件：" class="headerlink" title="在unity中使用行为树插件："></a>在unity中使用行为树插件：</h3><p>这边进行样例演示</p>
<h2 id="GOAP-Goal-Orentated-Action-planning"><a href="#GOAP-Goal-Orentated-Action-planning" class="headerlink" title="GOAP(Goal Orentated Action planning):"></a>GOAP(Goal Orentated Action planning):</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>目标导向型行动计划（简称GOAP）是一种能够轻松呈现给你的代理选择的AI系统，也是帮助你可以无需维持一个庞大且复杂的有限状态机而做出明智的决策的机器。GOAP的一个Action只有在其所有前提条件都得到满足的情况下才能执行，并且每个动作都会以某种方式改变世界的状态。</p>
<p>也就是， 让AI创造他们自己的方法去解决问题，我们提供给它一系列可能的动作作为对这个世界的描述，和每个动作使用的先决条件，和行动带来的影响。AI拥有一个初始状态和他需要达到的目标。有一组目标，AI可以通过优先级或当前状态选择一个。计划系统决定一个动作序列来满足当 前目标，计划出一个像路径一样的能最简单达到目标状态的动作序列。</p>
<h3 id="GOAP使用场景"><a href="#GOAP使用场景" class="headerlink" title="GOAP使用场景"></a>GOAP使用场景</h3><p>所有需要用到复杂AI的地方都可以使用，为什么非要是复杂AI呢，因为简单AI用FSM或行为树足以干净利落的解决问题，就没必要舍近求远了，那么这个复杂和简单用什么来界定呢，我在这里说一下我的标准，如果一个FSM的连线或者切换关系已经让人感觉一团糟，一个行为树的树状图非常庞大（100起），这个时候，你就可以考虑使用GOAP来化解难题了。</p>
<h3 id="GOAP中的一些概念"><a href="#GOAP中的一些概念" class="headerlink" title="GOAP中的一些概念"></a>GOAP中的一些概念</h3><p>WorldState,Condition,Sensor,Action,A*</p>
<p>Action：它由前提条件（PreCondition）和效果（Effect）组成，一般都是键值对，要执行一个Action，需要先检查前提条件是否满足，然后再把效果内容加入到Memory中（可选）</p>
<p>Goal：AI的目标，也是包含一个或多个键值对，会以此为基准使用A*算法展开路径搜索。例如：</p>
<p>Memory：AI的记忆，更新维护AI所认知的世界状态，偏静态。例如：{‘hasMoney’: true}</p>
<p>Sensor：感知者，其本质和Memory一样，但是偏动态，之所以需要他是因为我们很多时候需要做一下逻辑处理才会把世界状态写入Memory，例如，AI在血量小于30%时会寻找掩护物，要处理这个过程，我们需要一个Sensor来订阅AI的血量改变状态，每次改变就判断是否小于30%，如果是，就把Memory中”isInDanger”设置为true。</p>
<h3 id="具体示例："><a href="#具体示例：" class="headerlink" title="具体示例："></a>具体示例：</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Action：&#123;名称：建造Axe&#125;，&#123;先决条件：hasWood = true，hasSteel = true&#125;，&#123;效果：hasAxe = true，hasWood = false，hasSteel = false&#125;，&#123;权重：10&#125;</span></span><br><span class="line">ReGoapTestsHelper.GetCustomAction(gameObject, <span class="string">&quot;CreateAxe&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; &#123;&#123;<span class="string">&quot;hasWood&quot;</span>, <span class="literal">true</span>&#125;, &#123;<span class="string">&quot;hasSteel&quot;</span>, <span class="literal">true</span>&#125;&#125;,</span><br><span class="line">    <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; &#123;&#123;<span class="string">&quot;hasAxe&quot;</span>, <span class="literal">true</span>&#125;, &#123;<span class="string">&quot;hasWood&quot;</span>, <span class="literal">false</span>&#125;, &#123;<span class="string">&quot;hasSteel&quot;</span>, <span class="literal">false</span>&#125;&#125;, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//Action：&#123;名称：砍树&#125;，&#123;先决条件：无&#125;，&#123;效果：hasRawWood = true&#125;，&#123;权重：2&#125;</span></span><br><span class="line">ReGoapTestsHelper.GetCustomAction(gameObject, <span class="string">&quot;ChopTree&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; &#123; &#125;,</span><br><span class="line">    <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; &#123;&#123;<span class="string">&quot;hasRawWood&quot;</span>, <span class="literal">true</span>&#125;&#125;, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//Action：&#123;名称：加工原木&#125;，&#123;先决条件：hasRawWood = true&#125;，&#123;效果：hasRawWood = false，hasWood = true&#125;，&#123;权重：5&#125;</span></span><br><span class="line">ReGoapTestsHelper.GetCustomAction(gameObject, <span class="string">&quot;WorksWood&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; &#123;&#123;<span class="string">&quot;hasRawWood&quot;</span>, <span class="literal">true</span>&#125;&#125;,</span><br><span class="line">    <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; &#123;&#123;<span class="string">&quot;hasWood&quot;</span>, <span class="literal">true</span>&#125;, &#123;<span class="string">&quot;hasRawWood&quot;</span>, <span class="literal">false</span>&#125;&#125;, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//Action：&#123;名称：拥有矿山&#125;，&#123;先决条件：无&#125;，&#123;效果：hasOre = true&#125;，&#123;权重：10&#125;</span></span><br><span class="line">ReGoapTestsHelper.GetCustomAction(gameObject, <span class="string">&quot;MineOre&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; &#123; &#125;,</span><br><span class="line">    <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; &#123;&#123;<span class="string">&quot;hasOre&quot;</span>, <span class="literal">true</span>&#125;&#125;, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//Action：&#123;名称：加工矿石&#125;，&#123;先决条件：hasOre = true&#125;，&#123;效果：hasOre = false，hasSteel = ture&#125;，&#123;权重：10&#125;</span></span><br><span class="line">ReGoapTestsHelper.GetCustomAction(gameObject, <span class="string">&quot;SmeltOre&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; &#123;&#123;<span class="string">&quot;hasOre&quot;</span>, <span class="literal">true</span>&#125;&#125;,</span><br><span class="line">    <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; &#123;&#123;<span class="string">&quot;hasSteel&quot;</span>, <span class="literal">true</span>&#125;, &#123;<span class="string">&quot;hasOre&quot;</span>, <span class="literal">false</span>&#125;&#125;, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//Goal：&#123;名称：拥有Axe&#125;，&#123;目标状态：hasAxe = true&#125;，&#123;优先级：1&#125;</span></span><br><span class="line"><span class="keyword">var</span> hasAxeGoal = ReGoapTestsHelper.GetCustomGoal(gameObject, <span class="string">&quot;HasAxeGoal&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; &#123;&#123;<span class="string">&quot;hasAxe&quot;</span>, <span class="literal">true</span>&#125;&#125;, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//Goal：&#123;名称：拥有Axe和矿山&#125;，&#123;目标状态：hasAxe = true，hasOre = true，isGreedy = true&#125;，&#123;优先级：2&#125;</span></span><br><span class="line"><span class="keyword">var</span> greedyHasAxeAndOreGoal = ReGoapTestsHelper.GetCustomGoal(gameObject, <span class="string">&quot;GreedyHasAxeAndOreGoal&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; &#123;&#123;<span class="string">&quot;hasAxe&quot;</span>, <span class="literal">true</span>&#125;, &#123;<span class="string">&quot;hasOre&quot;</span>, <span class="literal">true</span>&#125;, &#123;<span class="string">&quot;isGreedy&quot;</span>, <span class="literal">true</span>&#125;&#125;,</span><br><span class="line">    <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210916152958.png!webp" alt="image-20210916152957981"></p>
<p>那么，我们现在开始进行规划，现在有两个目标，而GoalZ的优先级大于GoalY，所以会先把GoalZ纳入规划目标，但是我们找不到“贪婪的”这一状态，所以这个目标规划失败了，然后去尝试规划GoalY，它的规划结果如下</p>
<p>即：ActionA-&gt;ActionC-&gt;ActionB-&gt;ActionD-&gt;ActionE</p>
<p>这似乎与我们所想的ActionA-&gt;ActionB-&gt;ActionC-&gt;ActionD-&gt;ActionE结果不同，这是因为ReGoap中使用的A*是从终点-&gt;起点，而不是起点-&gt;终点的，这就会导致它只可以保证综合结果的Cost一定是所有规划里最小的，但在单次规划中并不会确定性采用权值较小的Action为下一结点，这样做是有考虑的，因为如果是从起点到终点进行的规划，就会多出非常多的可能性，更多的可能性意味着更多的计算，这对于要求低延迟的游戏造成的后果是不可接受的。</p>
<h3 id="与行为树和状态机的对比"><a href="#与行为树和状态机的对比" class="headerlink" title="与行为树和状态机的对比"></a>与行为树和状态机的对比</h3><p><strong>缺点</strong></p>
<ul>
<li>GOAP学习成本偏高</li>
<li>GOAP默认不保证Action顺序，如果我们想要强制指定顺序，需要额外做一些操作，但是一般而言我们的AI也不会去在意这种无关紧要的顺序，因为重要的顺序我们已经规范好了。</li>
<li>GOAP毕竟使用了运行时规划，会对游戏性能产生一定的影响，但是这种目标导向的A*规划在AI复杂的情况下，性能并不一定比FSM&#x2F;行为树弱。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>解耦目标和行为，设计时可以更加专注的设计AI的行为不用过多考虑目标，新增，减少Action非常方便，不会像FSM&#x2F;行为树那样具有那么强的入侵性和破坏性，提高了开发效率</li>
<li>动态规划的能力，这会使我们的AI看起来更加“智能”</li>
<li>配置方便，易于理解，完全可以让策划使用EXCEL接管AI开发工作</li>
</ul>
<h2 id="HTN（Hierarchical-Task-Networks）："><a href="#HTN（Hierarchical-Task-Networks）：" class="headerlink" title="HTN（Hierarchical Task Networks）："></a>HTN（Hierarchical Task Networks）：</h2><h3 id="学习资料："><a href="#学习资料：" class="headerlink" title="学习资料："></a>学习资料：</h3><p><a href="https://www.zhihu.com/question/323258599/answer/1941657770">(3 封私信 &#x2F; 45 条消息) 学习HTN规划技术要了解哪些东西? - 知乎 (zhihu.com)</a></p>
<h3 id="概念介绍："><a href="#概念介绍：" class="headerlink" title="概念介绍："></a>概念介绍：</h3><p>在AI开发中，一个普遍需要解决的问题是行为选择。这个问题有很多解决方案，比如FSM有限状态机、行为树、基于效用的选择、神经网络和规划器。这篇文章通过利用在开发过程中可能遇到的现实世界中的项目例子来探究一个类型规划器的细微差别，这类规划器称为分层任务网络(HTN)规划器。</p>
<p>HTN这样的规划器架构，是将一个问题作为输入，并提供一系列解决问题的步骤。在HTN术语中，这一系列步骤称为一个计划(plan)。HTN相对于其他规划器的独特之处在于，它允许我们把问题表现为一个非常高级（抽象）的计划(plan)，通过它的规划过程，递归地把这个任务分解成更小的任务。当这个过程完成时，剩下生成的是一组表示计划(plan)的原子任务。</p>
<h3 id="关键词："><a href="#关键词：" class="headerlink" title="关键词："></a>关键词：</h3><p>自前往后，任务，分解任务，运行时规划</p>
<h4 id="大致架构"><a href="#大致架构" class="headerlink" title="大致架构"></a>大致架构</h4><p><img src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/ef0a710c-364b-4997-98b0-7ddacdca53d3_image.png" alt="img"></p>
<h3 id="详细概念："><a href="#详细概念：" class="headerlink" title="详细概念："></a>详细概念：</h3><h4 id="世界状态（The-World-State）"><a href="#世界状态（The-World-State）" class="headerlink" title="世界状态（The World State）"></a>世界状态（The World State）</h4><p>世界状态（World State）是指在任何给定时间点，描绘环境和代理（通常是游戏中的角色或者是一个自主的软件代理）属性的一组变量或属性值。这些变量或属性值描述了环境和代理当前的情况，允许规划系统根据这些信息做出决策。</p>
<h4 id="传感器（Sensor）"><a href="#传感器（Sensor）" class="headerlink" title="传感器（Sensor）"></a>传感器（Sensor）</h4><p>传感器(sensor)可以管理不同的世界状态(world state)属性。一些不同传感器的例子包括视觉、听觉、范围和生命值传感器。这些传感器的工作原理与任何其他人工智能系统相同，只是增加了一个步骤，即把它们的信息编码成我们的HTN能够理解的世界状态(world state)。</p>
<h4 id="原子任务（Primitive-Tasks"><a href="#原子任务（Primitive-Tasks" class="headerlink" title="原子任务（Primitive Tasks)"></a>原子任务（Primitive Tasks)</h4><p>原子任务是指不能再被分解为更小任务的基础任务。它们是HTN执行过程中的最基本单位，直接映射到实际动作或操作上。原子任务通常与特定的动作相对应，这些动作在世界状态上具有直接影响，改变环境或者代理的状态。</p>
<p>假设有一个探索游戏，其中的HTN规划目标是让角色寻找并收集游戏世界中的特定资源。这个过程可能包括复合任务，如“探索区域”和“收集资源”。其中，“探索区域”可能进一步分解为“移动到区域A”和“搜索区域A”，最终，“移动到区域A”这种动作就是一个原子任务，因为它直接对应到游戏世界中的一个不可再分的动作。</p>
<h4 id="复合任务（Composite-Tasks）"><a href="#复合任务（Composite-Tasks）" class="headerlink" title="复合任务（Composite Tasks）"></a>复合任务（Composite Tasks）</h4><p>复合任务是指可以被进一步分解为更多子任务（复合任务或原子任务）的任务。这种任务的分解是基于任务的层次结构进行的，其目的是通过逐层分解来简化问题解决过程，直至所有的任务被分解为可直接执行的原子任务。</p>
<p>以一个简化的机器人清理房间的任务为例，顶层的复合任务可能是“清理房间”。这个任务可以进一步分解为“清理地板”和“整理桌子”两个复合任务。继续分解，“清理地板”可能变为“扫地”和“拖地”两个原子任务，而“整理桌子”可能进一步分解为“拾起物品”和“擦拭桌面”等原子任务。</p>
<h4 id="方法（method）"><a href="#方法（method）" class="headerlink" title="方法（method）"></a>方法（method）</h4><p>“方法”用于描述如何将复合任务分解成更具体的子任务序列。这些子任务可以是进一步的复合任务，需要继续分解，或者是原子任务，直接对应于可执行的动作。方法基本上定义了从高层任务到更低层、更具体任务之间的分解规则和逻辑。</p>
<h4 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h4><p>复合任务实际上只是一组方法(method)的容器，这些方法(method)每一个都是用来表示完成某个高级任务的不同方式</p>
<p><img src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/db2db7e0-546b-4eb6-ac80-d365d11dd2f8_image.png" alt="img"></p>
<h4 id="计划（Plan）"><a href="#计划（Plan）" class="headerlink" title="计划（Plan）"></a>计划（Plan）</h4><p>计划（plan）是指从初始状态到达目标状态的一系列可执行动作的组合。这些动作是通过对初步任务（可能是一个或多个复合任务）的逐步分解和具体化得到的。最终，这些动作被组织成一个顺序或有时是并行的执行序列，旨在完成给定的目标或任务。</p>
<p>假设有一个机器人在仓库环境中的任务是从仓库的一端将一箱货物移动到另一端，并且途中需要避开障碍物。</p>
<ol>
<li><p><strong>高层任务</strong>：将货物从A点移动到B点。</p>
</li>
<li><p>复合任务分解</p>
<p>：这个高层任务可以分解为几个子任务：</p>
<ul>
<li>定位货物。</li>
<li>搬起货物。</li>
<li>规划到达B点的路径，考虑避开障碍物。</li>
<li>沿规划路径移动货物。</li>
<li>在B点放下货物。</li>
</ul>
</li>
</ol>
<h4 id="规划器（Planner）"><a href="#规划器（Planner）" class="headerlink" title="规划器（Planner）"></a>规划器（Planner）</h4><p>（Planner）是一个核心组件，负责执行整个规划流程，即从初始状态开始，通过逐步分解任务并应用相应的方法，最终生成一个实现目标的计划。</p>
<p>伪代码实现：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//规划（核心）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Plan</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先复制一份世界状态</span></span><br><span class="line">    <span class="keyword">var</span> worldState = HTNWorld.CopyWorldState();</span><br><span class="line">    <span class="comment">//将存储列表清空，避免上次计划结果的影响</span></span><br><span class="line">    FinalTasks.Clear();</span><br><span class="line">    <span class="comment">//将根任务压进栈中，准备分解</span></span><br><span class="line">    taskOfProcess.Push(rootTask);</span><br><span class="line">    <span class="comment">//只要栈还没空，就继续分解</span></span><br><span class="line">    <span class="keyword">while</span>(taskOfProcess.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拿出栈顶的元素</span></span><br><span class="line">        <span class="keyword">var</span> task = taskOfProcess.Pop();</span><br><span class="line">        <span class="comment">//如果这个元素是复合任务</span></span><br><span class="line">        <span class="keyword">if</span>(task <span class="keyword">is</span> CompoundTask cTask)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判断是否可以执行</span></span><br><span class="line">            <span class="keyword">if</span>(cTask.MetCondition(worldState))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*如果可以执行，就肯定有可用的方法，</span></span><br><span class="line"><span class="comment">                就将该方法的子任务都压入栈中，以便继续分解*/</span></span><br><span class="line">                <span class="keyword">var</span> subTask = cTask.ValidMethod.SubTask;</span><br><span class="line">                <span class="keyword">foreach</span>(<span class="keyword">var</span> t <span class="keyword">in</span> subTask)</span><br><span class="line">                &#123;</span><br><span class="line">                    taskOfProcess.Push(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*通过上面的步骤我们知道，能被压进栈中的只有</span></span><br><span class="line"><span class="comment">                复合任务和原子任务，方法本身并不会入栈*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//否则，这个元素就是原子任务</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将该元素转为原子任务，因为原本是IBaseTask类型</span></span><br><span class="line">            <span class="keyword">var</span> pTask = task <span class="keyword">as</span> PrimitiveTask;</span><br><span class="line">            <span class="comment">//再将该原子任务加入存放分解完成的任务列表</span></span><br><span class="line">            FinalTasks.Push(pTask);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行器："><a href="#执行器：" class="headerlink" title="执行器："></a>执行器：</h4><p>规划器的要点在于对「复合任务」的分解，这里提一下，一个HTN会保证有一个复合任务做为根任务，就和行为树的根节点一样。分解也是由此开始：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于描述运行结果的枚举（如果有看上一篇行为树的话</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> EStatus</span><br><span class="line">&#123;</span><br><span class="line">    Failure, Success, Running, </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HTNPlanRunner</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当前运行状态</span></span><br><span class="line">    <span class="keyword">private</span> EStatus curState;</span><br><span class="line">    <span class="comment">//直接将规划器包含进来，方便重新规划</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HTNPlanner planner;</span><br><span class="line">    <span class="comment">//当前执行的原子任务</span></span><br><span class="line">    <span class="keyword">private</span> PrimitiveTask curTask;</span><br><span class="line">    <span class="comment">//标记「原子任务列表是否还有元素、能够继续」</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> canContinue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HTNPlanRunner</span>(<span class="params">HTNPlanner planner</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.planner = planner;</span><br><span class="line">        curState = EStatus.Failure;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RunPlan</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前运行状态是失败（一开始默认失败）</span></span><br><span class="line">        <span class="keyword">if</span>(curState == EStatus.Failure)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//就规划一次</span></span><br><span class="line">            planner.Plan();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前运行状态是成功，就表示当前任务完成了</span></span><br><span class="line">        <span class="keyword">if</span>(curState == EStatus.Success)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//让当前原子任务造成影响</span></span><br><span class="line">            curTask.Effect();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*如果当前状态不是「正在执行」，就取出新一个原子任务作为当前任务</span></span><br><span class="line"><span class="comment">        无论失败还是成功，都要这么做。因为如果是失败，肯定在代码运行到这</span></span><br><span class="line"><span class="comment">        之前，已经进行了一次规划，理应获取新规划出的任务来运行；如果是因</span></span><br><span class="line"><span class="comment">        为成功，那也要取出新任务来运行*/</span></span><br><span class="line">        <span class="keyword">if</span>(curState != EStatus.Running)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//用TryPop的返回结果判断规划器的FinalTasks是否为空</span></span><br><span class="line">            canContinue = planner.FinalTasks.TryPop(<span class="keyword">out</span> curTask);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*如果canContinue为false，那curTask会为null也视作失败（其实应该是「全部</span></span><br><span class="line"><span class="comment">        完成」，但全部完成和失败是一样的，都要重新规划）。所以只有当canContinue &amp;&amp; curTask.MetCondition()都满足时，才读取当前原子任务的运行状态，否则就失败。*/</span></span><br><span class="line">        curState = canContinue &amp;&amp; curTask.MetCondition() ? curTask.Operator() : EStatus.Failure;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="只狼的游戏AI—-以弦一郎为例（行为树与HTN的结合，变种的HTN或者行为树）"><a href="#只狼的游戏AI—-以弦一郎为例（行为树与HTN的结合，变种的HTN或者行为树）" class="headerlink" title="只狼的游戏AI—-以弦一郎为例（行为树与HTN的结合，变种的HTN或者行为树）"></a>只狼的游戏AI—-以弦一郎为例（行为树与HTN的结合，变种的HTN或者行为树）</h2><h4 id="写在开头："><a href="#写在开头：" class="headerlink" title="写在开头："></a>写在开头：</h4><p><strong>动作游戏是贩卖关于强大角色或能力的幻想</strong>。</p>
<h4 id="AI结构："><a href="#AI结构：" class="headerlink" title="AI结构："></a>AI结构：</h4><p>FromSoftWare的ai配置是用lua进行配置</p>
<p><em>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</em></p>
<p><img src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/b301c86dd22698c44a8deee8d327ef0a-910-775.png" alt="img"></p>
<p><img src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/v2-d7c4bba0d6c91ccc34418a46ccb09579_r.jpg" alt="img"></p>
<ul>
<li><p><strong>Goal.Activate主动计划——自由态时调用</strong> 根据与玩家距离、方位、状态，从众多任务里随机选择一个执行。任务的随机是有权重的，按照设定的权重分配</p>
<p><img src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/v2-1a700dcc21f30e50aebd5dc026bc3b7e_r.jpg" alt="img"></p>
</li>
<li><p><strong>Goal.Interrupt变招计划——不只是读指令</strong> 由于玩家角色的特定行为，中断原有计划转为执行其他动作的计划。</p>
<p><img src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/v2-a89d37d7d98d4513371099c8176dffe9_1440w.webp" alt="img"></p>
</li>
<li><p><strong>Goal.Kengeki交锋计划</strong> 根据玩家格挡或自身格挡的结果判断，从众多任务里随机选择一个执行。</p>
</li>
</ul>
<p><img src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/v2-7d8f1b034d1e02bce986187dd8e9ae22_r.jpg" alt="img"></p>
]]></content>
      <tags>
        <tag>unity</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>回合制buff系统架构</title>
    <url>/2024/06/03/%E5%9B%9E%E5%90%88%E5%88%B6buff%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="在unity中的一个比较完善的回合制buff系统框架"><a href="#在unity中的一个比较完善的回合制buff系统框架" class="headerlink" title="在unity中的一个比较完善的回合制buff系统框架"></a>在unity中的一个比较完善的回合制buff系统框架</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>​	在前两个月开发的的cusga，笔者仿照猴叔的可扩展俯视角射击<a href="https://zhuanlan.zhihu.com/p/416805924">用Unity制作一个极具扩展性的顶视角射击游戏战斗系统 - 知乎 (zhihu.com)</a></p>
<p>完成了游戏中的buff系统的构建，经过了一些小小的魔改，在配置上和扩展上达到了可以接受的程度，但是还是饱受另一位配置的程序的诟病，于是有了这篇文章，基于之前的框架，进行一些重构，来达到配置更简单，更容易扩展的目的。</p>
<h2 id="原本的buff系统："><a href="#原本的buff系统：" class="headerlink" title="原本的buff系统："></a>原本的buff系统：</h2><h3 id="原本buff系统组成："><a href="#原本buff系统组成：" class="headerlink" title="原本buff系统组成："></a>原本buff系统组成：</h3><p>(本buff系统基本上来自于猴叔的架构，所以看过猴叔的可以简单地跳过)</p>
<h4 id="BuffData"><a href="#BuffData" class="headerlink" title="BuffData"></a>BuffData</h4><p>原本的buff系统大体由BuffData,BuffInfo,BuffHandler组成，其中buffData是buff的基础配置，是静态的配置，由一些buff的信息和回调点的delegate以及各个delegate的参数组成（关于回调点的概念，请参考上面的知乎文章，另外，在旧的buff系统中，其实回调点参数都没有使用），buffdata的具体定义如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BuffData</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> buff的唯一id</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> id;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> buff的名字</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> buffName;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 存储buff的icon图标的路径，resoueces读取，后面没用上</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> buffIcon;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用于方便检索的tag，例如：火焰，冰冻，中毒等</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>[] tags;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> buff的最高层数</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> maxStack;</span><br><span class="line">    <span class="comment">//当buff的层数发生变化时，buff的更新策略</span></span><br><span class="line">    <span class="keyword">public</span> BuffUpdateEnum buffUpdateEnum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BuffRemoveStackUpdateEnum removeStackUpdateEnum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//buff的时间信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> duringCount;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 是否是永久的buff</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isPermanent;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> buff会给角色添加的属性，暂定两种，一种加算，一种乘算</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> ChaProperty[] propMod;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> buff对于角色状态的修改</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> ChaControlState stateMod;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> buff在创建的时候的事件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> OnBuffCreate onCreate;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span>[] onCreateParams;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> buff在移除的时候的事件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> OnBuffRemove onRemove;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span>[] onRemoveParams;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 在回合开始的时候的触发的事件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> OnRoundStart onRoundStart;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span>[] onRoundStartParams;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 在回合结束的时候触发的事件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> OnRoundEnd onRoundEnd;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span>[] onRoundEndParams;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 在伤害流程中，持有这个buff的角色作为攻击者时触发的事件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> BuffOnHit onHit;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span>[] onHitParams;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 在伤害流程中，持有这个buff的角色作为被攻击者时触发的事件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> BuffOnBeHurt onBeHurt;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span>[] onBeHurtParams;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 在开局玩家操作阶段roll骰子时触发的事件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> BuffOnRoll onRoll;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span>[] onRollParams;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 在伤害流程中，如果击杀目标，会触发的事件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> BuffOnkill onKill;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span>[] onKillParams;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BuffOnBeKilled onBeKilled;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span>[] onBeKilledParams;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BuffOnCast OnCast;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span>[] onCastParams;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> OnAddBuff onAddBuff;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span>[] onAddBuffParams;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> OnGetFinalDamage onGetFinalDamage;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span>[] onGetFinalDamageParams;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BuffData</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> id, <span class="built_in">string</span> name, <span class="built_in">string</span> icon, <span class="built_in">string</span>[] tags, <span class="built_in">int</span> maxStack, <span class="built_in">int</span> duringCount, <span class="built_in">bool</span> isPermanent,</span></span></span><br><span class="line"><span class="params"><span class="function">        BuffUpdateEnum buffUpdateEnum, BuffRemoveStackUpdateEnum removeStackUpdateEnum,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> onCreate, <span class="built_in">object</span>[] onCreateParams,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> onRemove, <span class="built_in">object</span>[] onRemoveParams,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> onRoundStart, <span class="built_in">object</span>[] onRoundStartParams,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> onRoundEnd, <span class="built_in">object</span>[] onRoundEndParams,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> onHit, <span class="built_in">object</span>[] onHitParams,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> onBeHurt, <span class="built_in">object</span>[] onBeHurtParams,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> onRoll, <span class="built_in">object</span>[] onRollParams,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> onKill, <span class="built_in">object</span>[] onKillParams,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> onBeKilled, <span class="built_in">object</span>[] onBeKilledParams,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> onCast, <span class="built_in">object</span>[] onCastParams,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> onAddBuff, <span class="built_in">object</span>[] onAddBuffParams,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> onGetFinalDamage, <span class="built_in">object</span>[] onGetFinalDamageParams,</span></span></span><br><span class="line"><span class="params"><span class="function">        ChaControlState stateMod, ChaProperty[] propMod = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">        </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.buffName = name;</span><br><span class="line">        <span class="keyword">this</span>.buffIcon = icon;</span><br><span class="line">        <span class="keyword">this</span>.tags = tags;</span><br><span class="line">        <span class="keyword">this</span>.maxStack = maxStack;</span><br><span class="line">        <span class="keyword">this</span>.duringCount = duringCount;</span><br><span class="line">        <span class="keyword">this</span>.isPermanent = isPermanent;</span><br><span class="line">        <span class="keyword">this</span>.propMod = <span class="keyword">new</span> ChaProperty[<span class="number">2</span>]</span><br><span class="line">            &#123;ChaProperty.zero,</span><br><span class="line">             ChaProperty.zero</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (propMod != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; Mathf.Min(propMod.Length, <span class="number">2</span>); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.propMod[i] = propMod[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stateMod = stateMod;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.onCreate = (onCreate == <span class="string">&quot;&quot;</span> )? <span class="literal">null</span> : DesignerScripts.BuffEvents.onCreateFunc[onCreate];</span><br><span class="line">        <span class="keyword">this</span>.onCreateParams = onCreateParams;</span><br><span class="line">        <span class="keyword">this</span>.onRemove = (onRemove == <span class="string">&quot;&quot;</span>) ? <span class="literal">null</span> : DesignerScripts.BuffEvents.onRemoveFunc[onRemove];</span><br><span class="line">        <span class="keyword">this</span>.onRemoveParams = onRemoveParams;</span><br><span class="line">        <span class="keyword">this</span>.onRoundStart = (onRoundStart == <span class="string">&quot;&quot;</span>) ? <span class="literal">null</span> : DesignerScripts.BuffEvents.onRoundStartFunc[onRoundStart];</span><br><span class="line">        <span class="keyword">this</span>.onRoundStartParams = onRoundStartParams;</span><br><span class="line">        <span class="keyword">this</span>.onRoundEnd = (onRoundEnd == <span class="string">&quot;&quot;</span>) ? <span class="literal">null</span> : DesignerScripts.BuffEvents.onRoundEndFunc[onRoundEnd];</span><br><span class="line">        <span class="keyword">this</span>.onRoundEndParams = onRoundEndParams;</span><br><span class="line">        <span class="keyword">this</span>.onHit = (onHit == <span class="string">&quot;&quot;</span>) ? <span class="literal">null</span> : DesignerScripts.BuffEvents.onBuffHitFunc[onHit];</span><br><span class="line">        <span class="keyword">this</span>.onHitParams = onHitParams;</span><br><span class="line">        <span class="keyword">this</span>.onBeHurt = (onBeHurt == <span class="string">&quot;&quot;</span>) ? <span class="literal">null</span> : DesignerScripts.BuffEvents.onBeHurtFunc[onBeHurt];</span><br><span class="line">        <span class="keyword">this</span>.onBeHurtParams = onBeHurtParams;</span><br><span class="line">        <span class="keyword">this</span>.onRoll = (onRoll == <span class="string">&quot;&quot;</span>) ? <span class="literal">null</span> : DesignerScripts.BuffEvents.onRollFunc[onRoll];</span><br><span class="line">        <span class="keyword">this</span>.onRollParams = onRollParams;</span><br><span class="line">        <span class="keyword">this</span>.onKill = (onKill == <span class="string">&quot;&quot;</span>) ? <span class="literal">null</span> : DesignerScripts.BuffEvents.onKillFunc[onKill];</span><br><span class="line">        <span class="keyword">this</span>.onKillParams = onKillParams;</span><br><span class="line">        <span class="keyword">this</span>.onBeKilled = (onBeKilled == <span class="string">&quot;&quot;</span>) ? <span class="literal">null</span> : DesignerScripts.BuffEvents.onBeKillFunc[onBeKilled];</span><br><span class="line">        <span class="keyword">this</span>.onBeKilledParams = onBeKilledParams;</span><br><span class="line">        <span class="keyword">this</span>.OnCast = (onCast == <span class="string">&quot;&quot;</span>) ? <span class="literal">null</span> : DesignerScripts.BuffEvents.onCastFunc[onCast];</span><br><span class="line">        <span class="keyword">this</span>.onCastParams = onCastParams;</span><br><span class="line">        <span class="keyword">this</span>.onAddBuff = (onAddBuff == <span class="string">&quot;&quot;</span>) ? <span class="literal">null</span> : DesignerScripts.BuffEvents.onAddFunc[onAddBuff];</span><br><span class="line">        <span class="keyword">this</span>.onAddBuffParams = onAddBuffParams;</span><br><span class="line">        <span class="keyword">this</span>.onGetFinalDamage = (onGetFinalDamage == <span class="string">&quot;&quot;</span>) ? <span class="literal">null</span> : DesignerScripts.BuffEvents.onGetFinalDamageFunc[onGetFinalDamage];</span><br><span class="line">        <span class="keyword">this</span>.onGetFinalDamageParams = onGetFinalDamageParams;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> buff的创建，移除，回合开始，回合结束，被攻击，攻击，被击杀，击杀等事件</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;buff&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">OnBuffCreate</span>(<span class="params">BuffInfo buff</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">OnBuffRemove</span>(<span class="params">BuffInfo buff</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">OnRoundStart</span>(<span class="params">BuffInfo buff</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">OnRoundEnd</span>(<span class="params">BuffInfo buff</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">BuffOnHit</span>(<span class="params">BuffInfo buff, DamageInfo damageInfo, GameObject target</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">BuffOnBeHurt</span>(<span class="params">BuffInfo buff, DamageInfo damageInfo, GameObject attacker</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">BuffOnRoll</span>(<span class="params">BuffInfo buffInfo</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">BuffOnkill</span>(<span class="params">BuffInfo buffInfo, DamageInfo damageInfo, GameObject target</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">BuffOnBeKilled</span>(<span class="params">BuffInfo buffInfo, DamageInfo damageInfo, GameObject attacker</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> SingleDiceObj <span class="title">BuffOnCast</span>(<span class="params">BuffInfo buffInfo, SingleDiceObj singleDiceObj</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">OnAddBuff</span>(<span class="params">BuffInfo buffInfo</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">OnGetFinalDamage</span>(<span class="params">BuffInfo buffInfo,DamageInfo damageInfo</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到基本上和猴叔的buffData定义保持一致，只不过做出了一些基于回合制的特别改动，例如回调点的改动以及一些参数描述上的的改动（待补充）</p>
<h4 id="BuffInfo"><a href="#BuffInfo" class="headerlink" title="BuffInfo"></a>BuffInfo</h4><p>接下来是buffInfo,buff,BuffInfo是运行时实时进行刷新的buff实例，需要注意的是，这边的buff信息的架构并没有采用猴叔的三层架构，而是只采用了两层，所以代码会有些不同，完整代码如下</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BuffInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> buff数据的模板</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> BuffData buffData;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> buff是否是永久的</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isPermanent;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> buff的创建者</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> GameObject creator = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> buff的目标</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> GameObject target = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 回合计数器</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> roundCount;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 执行次数</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ticked = <span class="number">0</span>;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 当前buff的层数</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> curStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; buffParam = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BuffInfo</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        BuffData buffData, GameObject creator, GameObject target, <span class="built_in">int</span> stack = <span class="number">1</span>, <span class="built_in">bool</span> isPermanent = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; buffParam = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">        </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.buffData = buffData;</span><br><span class="line">        <span class="keyword">this</span>.creator = creator;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">this</span>.curStack = stack;</span><br><span class="line">        <span class="keyword">this</span>.isPermanent = buffData.isPermanent;</span><br><span class="line">        <span class="comment">//this.isPermanent = buffData.isPermanent;</span></span><br><span class="line">        <span class="keyword">this</span>.roundCount = buffData.duringCount;</span><br><span class="line">        <span class="keyword">if</span> (buffParam != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> buffParam)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.buffParam.Add(item.Key, item.Value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BuffInfo</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        BuffData buffData, <span class="built_in">int</span> stack = <span class="number">1</span>, <span class="built_in">bool</span> isPermanent = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; buffParam = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">        </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.buffData = buffData;</span><br><span class="line">        <span class="keyword">this</span>.curStack = stack;</span><br><span class="line">        <span class="keyword">this</span>.isPermanent = isPermanent;</span><br><span class="line">        <span class="keyword">this</span>.roundCount = buffData.duringCount;</span><br><span class="line">        <span class="keyword">if</span> (buffParam != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> buffParam)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.buffParam.Add(item.Key, item.Value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//深拷贝</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BuffInfo</span>(<span class="params">BuffInfo buffInfo</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.buffData =buffInfo.buffData;</span><br><span class="line">        <span class="keyword">this</span>.creator = buffInfo.creator;</span><br><span class="line">        <span class="keyword">this</span>.target = buffInfo.target;</span><br><span class="line">        <span class="keyword">this</span>.curStack = buffInfo.curStack;</span><br><span class="line">        <span class="keyword">this</span>.isPermanent = buffInfo.isPermanent;</span><br><span class="line">        <span class="keyword">this</span>.buffParam = buffInfo.buffParam;</span><br><span class="line">        <span class="keyword">this</span>.roundCount=buffInfo.roundCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> BuffRemoveStackUpdateEnum</span><br><span class="line">&#123;</span><br><span class="line">    Reduce,</span><br><span class="line">    Clear,</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> BuffUpdateEnum</span><br><span class="line">&#123;</span><br><span class="line">    Add,</span><br><span class="line">    Replace,</span><br><span class="line">    Keep</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>BuffInfo包含了一些Runtime比较重要的信息，以及运行时的额外参数，可以看到这边为了扩展性采用了string,object的字典,关于这边的构造函数，主要还是以需求为主，有需求再往上加。</p>
<h3 id="BuffHandler"><a href="#BuffHandler" class="headerlink" title="BuffHandler"></a>BuffHandler</h3><p>最后是BuffHandler，Buffhandler负责管理具体游戏中角色的buff的添加和删除，以及供外部调用触发回调点函数，当然这边的回调点函数是不完全的，在有些情况下会出问题，这个在后续会讲到。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BuffHandler</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Description(<span class="string">&quot;Buff列表&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> List&lt;BuffInfo&gt; buffList = <span class="keyword">new</span> List&lt;BuffInfo&gt;();</span><br><span class="line">    <span class="comment">//所有判断的时候如果buff需要移除，先加入这个列表，然后再进行移除</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;BuffInfo&gt; removeList = <span class="keyword">new</span> List&lt;BuffInfo&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddBuff</span>(<span class="params">BuffInfo buffInfo, GameObject creator</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//添加buff时候的回调点触发</span></span><br><span class="line">        buffInfo.creator = creator;</span><br><span class="line">        buffInfo.target = <span class="keyword">this</span>.gameObject;</span><br><span class="line">        HalidomManager.Instance.OnAddBuff(buffInfo);</span><br><span class="line">        BuffInfo findBuffInfo = buffList.Find(x =&gt; x.buffData.id == buffInfo.buffData.id);</span><br><span class="line">        <span class="keyword">if</span> (findBuffInfo != <span class="literal">null</span>)<span class="comment">//获得相同的buff的情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (findBuffInfo.curStack &lt; findBuffInfo.buffData.maxStack)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//findBuffInfo.curStack++;</span></span><br><span class="line">                <span class="keyword">if</span> (findBuffInfo.curStack + buffInfo.curStack &gt; findBuffInfo.buffData.maxStack)</span><br><span class="line">                &#123;</span><br><span class="line">                    findBuffInfo.curStack = buffInfo.buffData.maxStack;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    findBuffInfo.curStack += buffInfo.curStack;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">switch</span> (findBuffInfo.buffData.buffUpdateEnum)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> BuffUpdateEnum.Add:</span><br><span class="line">                        findBuffInfo.roundCount += findBuffInfo.buffData.duringCount;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> BuffUpdateEnum.Replace:</span><br><span class="line">                        findBuffInfo.roundCount = findBuffInfo.buffData.duringCount;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> BuffUpdateEnum.Keep:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="literal">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> charac = (Character)findBuffInfo.target.GetComponent&lt;ChaState&gt;().side;</span><br><span class="line">                <span class="keyword">var</span> index = buffList.IndexOf(findBuffInfo);</span><br><span class="line">                BuffUIManager.Instance.UpdateBuffDurationTime(charac, index, findBuffInfo.curStack);</span><br><span class="line">                <span class="comment">//<span class="doctag">TODO:</span>提示buff层数增加,根据buff的类型进行不同的处理</span></span><br><span class="line">                findBuffInfo.buffData.onCreate?.Invoke(findBuffInfo);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//<span class="doctag">TODO:</span>提示buff层数已满</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            buffInfo.buffData.onCreate?.Invoke(buffInfo);</span><br><span class="line">            buffList.Add(buffInfo);</span><br><span class="line">            <span class="comment">//添加buffUI</span></span><br><span class="line">            <span class="keyword">var</span> charac = (Character)buffInfo.target.GetComponent&lt;ChaState&gt;().side;</span><br><span class="line">            BuffUIManager.Instance.CreateBuffUIObject(charac, buffInfo.buffData.id, buffInfo.curStack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 移除buff</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;buffInfo&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveBuff</span>(<span class="params">BuffInfo buffInfo</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (buffInfo.buffData.removeStackUpdateEnum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> BuffRemoveStackUpdateEnum.Clear:</span><br><span class="line">                buffInfo.buffData.onRemove?.Invoke(buffInfo);</span><br><span class="line">                <span class="built_in">int</span> index = buffList.IndexOf(buffInfo);</span><br><span class="line">                <span class="keyword">var</span> charac = (Character)buffInfo.target.GetComponent&lt;ChaState&gt;().side;</span><br><span class="line">                BuffUIManager.Instance.RemoveBuffUIObject(charac, index);</span><br><span class="line">                buffList.Remove(buffInfo);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BuffRemoveStackUpdateEnum.Reduce:</span><br><span class="line">                buffInfo.curStack--;</span><br><span class="line">                <span class="keyword">var</span> charac1 = (Character)buffInfo.target.GetComponent&lt;ChaState&gt;().side;</span><br><span class="line">                <span class="built_in">int</span> index1 = buffList.IndexOf(buffInfo);</span><br><span class="line">                BuffUIManager.Instance.UpdateBuffDurationTime(charac1, index1, buffInfo.curStack);</span><br><span class="line">                buffInfo.buffData.onRemove?.Invoke(buffInfo);</span><br><span class="line">                <span class="keyword">if</span> (buffInfo.curStack &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">int</span> i = buffList.IndexOf(buffInfo);</span><br><span class="line">                    <span class="keyword">var</span> c = (Character)buffInfo.target.GetComponent&lt;ChaState&gt;().side;</span><br><span class="line">                    BuffUIManager.Instance.RemoveBuffUIObject(c, i);</span><br><span class="line">                    buffList.Remove(buffInfo);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//<span class="doctag">TODO:</span>关于buff层数减少的刷新</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 每个回合开始的时候，对buff的时间进行处理,side表示当前是哪一方的回合</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 回调点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BuffRoundStartTick</span>(<span class="params"><span class="built_in">int</span> side</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (side == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; buffList.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (buffList[i].buffData.tags.Contains(<span class="string">&quot;PlayerOnRoundStart&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    buffList[i].buffData.onRoundStart?.Invoke(buffList[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (side == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; buffList.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (buffList[i].buffData.tags.Contains(<span class="string">&quot;EnemyOnRoundStart&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    buffList[i].buffData.onRoundStart?.Invoke(buffList[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span>每个回合结束的时候，对buff的时间进行处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BuffRoundEndTick</span>(<span class="params"><span class="built_in">int</span> side</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;BuffInfo&gt; removeList = <span class="keyword">new</span> List&lt;BuffInfo&gt;();</span><br><span class="line">        <span class="comment">//因为buffhandler既不知道是给谁挂载的，也不知道是什么回合，所以需要两个参数来判断</span></span><br><span class="line">        <span class="comment">//传入的是玩家并且当前是玩家的回合</span></span><br><span class="line">        <span class="keyword">if</span> (side == <span class="number">0</span> &amp;&amp; BattleManager.Instance.GetCurrentState() == BattleManager.Instance.GetStates()[GameState.PlayerRoundEndResolution])</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//触发玩家身上的有OnMyTurnEnd的buff</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> buff <span class="keyword">in</span> buffList)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (buff.buffData.tags.Contains(<span class="string">&quot;OnMyTurnEnd&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    buff.buffData.onRoundEnd?.Invoke(buff);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; buffList.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (buffList[i].buffData.tags.Contains(<span class="string">&quot;OnMyTurnEnd&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (buffList[i].isPermanent == <span class="literal">false</span>)<span class="comment">//非永久buff</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        buffList[i].roundCount--;</span><br><span class="line"></span><br><span class="line">                        buffList[i].roundCount = Mathf.Max(<span class="number">0</span>, buffList[i].roundCount);<span class="comment">//可能出现负数的情况</span></span><br><span class="line">                        <span class="keyword">if</span> (buffList[i].roundCount == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            removeList.Add(buffList[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; removeList.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                RemoveBuff(removeList[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//传入的是敌人 在玩家的回合结束</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (side == <span class="number">1</span> &amp;&amp; BattleManager.Instance.GetCurrentState() == BattleManager.Instance.GetStates()[GameState.PlayerRoundEndResolution])</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;传入的是敌人 在玩家的回合结束&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> buff <span class="keyword">in</span> buffList)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (buff.buffData.tags.Contains(<span class="string">&quot;OnOtherTurnEnd&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    buff.buffData.onRoundEnd?.Invoke(buff);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; buffList.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (buffList[i].buffData.tags.Contains(<span class="string">&quot;OnOtherTurnEnd&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (buffList[i].isPermanent == <span class="literal">false</span>)<span class="comment">//非永久buff</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        buffList[i].roundCount--;</span><br><span class="line"></span><br><span class="line">                        buffList[i].roundCount = Mathf.Max(<span class="number">0</span>, buffList[i].roundCount);<span class="comment">//可能出现负数的情况</span></span><br><span class="line">                        <span class="keyword">if</span> (buffList[i].roundCount == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            removeList.Add(buffList[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; removeList.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                RemoveBuff(removeList[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//传入的是玩家 在敌人的回合结束</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (side == <span class="number">0</span> &amp;&amp; BattleManager.Instance.GetCurrentState() == BattleManager.Instance.GetStates()[GameState.EnemyRoundEndResolution])</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;传入的是玩家 在敌人的回合结束&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> buff <span class="keyword">in</span> buffList)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (buff.buffData.tags.Contains(<span class="string">&quot;OnOtherTurnEnd&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    buff.buffData.onRoundEnd?.Invoke(buff);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; buffList.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (buffList[i].buffData.tags.Contains(<span class="string">&quot;OnOtherTurnEnd&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (buffList[i].isPermanent == <span class="literal">false</span>)<span class="comment">//非永久buff</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        buffList[i].roundCount--;</span><br><span class="line"></span><br><span class="line">                        buffList[i].roundCount = Mathf.Max(<span class="number">0</span>, buffList[i].roundCount);<span class="comment">//可能出现负数的情况</span></span><br><span class="line">                        <span class="keyword">if</span> (buffList[i].roundCount == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            removeList.Add(buffList[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; removeList.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                RemoveBuff(removeList[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传入的是敌人 在敌人的回合结束</span></span><br><span class="line">        <span class="keyword">if</span> (side == <span class="number">1</span> &amp;&amp; BattleManager.Instance.GetCurrentState() == BattleManager.Instance.GetStates()[GameState.EnemyRoundEndResolution])</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;传入的是敌人 在敌人的回合结束&quot;</span>);</span><br><span class="line">            <span class="comment">//触发敌人身上的有OnMyTurnEnd的buff</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> buff <span class="keyword">in</span> buffList)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (buff.buffData.tags.Contains(<span class="string">&quot;OnMyTurnEnd&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    buff.buffData.onRoundEnd?.Invoke(buff);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; buffList.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (buffList[i].buffData.tags.Contains(<span class="string">&quot;OnMyTurnEnd&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (buffList[i].isPermanent == <span class="literal">false</span>)<span class="comment">//非永久buff</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        buffList[i].roundCount--;</span><br><span class="line"></span><br><span class="line">                        buffList[i].roundCount = Mathf.Max(<span class="number">0</span>, buffList[i].roundCount);<span class="comment">//可能出现负数的情况</span></span><br><span class="line">                        <span class="keyword">if</span> (buffList[i].roundCount == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            removeList.Add(buffList[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; removeList.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                RemoveBuff(removeList[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BuffOnReRoll</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; buffList.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            buffList[i].buffData.onRoll?.Invoke(buffList[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//待定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BuffOnCast</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> buff <span class="keyword">in</span> buffList)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RecheckBuff</span>(<span class="params">ChaProperty[] buffProp, <span class="keyword">ref</span> ChaControlState chaControlState</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> buff <span class="keyword">in</span> buffList)</span><br><span class="line">        &#123;</span><br><span class="line">            buffProp[<span class="number">0</span>] += buff.buffData.propMod[<span class="number">0</span>] * buff.curStack;</span><br><span class="line">            buffProp[<span class="number">1</span>] += buff.buffData.propMod[<span class="number">1</span>];</span><br><span class="line">            chaControlState += buff.buffData.stateMod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><p>每一个收到buff影响的character身上都挂了一个buffHandler，其他的相关manager在合适的时候调用回调点触发函数，例如在受伤时的回调函数和攻击时的回调函数，就在damageManager中触发（关于damage的详细信息，见猴与花果山的文章）</p>
<h3 id="引擎内配置："><a href="#引擎内配置：" class="headerlink" title="引擎内配置："></a>引擎内配置：</h3><p><img src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/image-20240529225508974.png" alt="image-20240529225508974"></p>
<p>这是一个最简单buffSO的截图示例，采取了SO配置整体信息+脚本内配置回调点具体函数，在运行的时候初始化为buffData，由于一些原因，损失了每个回调点的参数，也无法进行回调点的组合和公用，因此只能说是堪堪能用。</p>
<p>大体的工作流如下：</p>
<p>先在写回调点event的脚本里写相应的buff的回调点函数，再手动加进相应的字典里，字典的key是回调点函数效果的枚举，因此也需要对对应相关回调点的enum进行修改，再将buffName添加进buffName的enum（其实名字直接用string也可以，因为配置步骤过多，所以enum不容易错），之后再在需要用到buffData的地方，从buffData的字典里找出相应的buffData,根据具体的情况生成buffInfo，加到具体角色身上的buffHandler的bufflist里</p>
<h2 id="新buff系统："><a href="#新buff系统：" class="headerlink" title="新buff系统："></a>新buff系统：</h2><h3 id="旧buff系统的问题："><a href="#旧buff系统的问题：" class="headerlink" title="旧buff系统的问题："></a>旧buff系统的问题：</h3><p>从上述的描述中，其实已经可以看出，先前的buff系统在各个方面都存在不少的问题，但是这边还是要具体列举一下开发中遇到的问题。</p>
<p>1、配置上的问题，配置的步骤太过繁琐导致容易出错，随着业务需求的增加，会很繁琐，也就是程序化的程度不够，需要指定一套相对比较完善的配置流程</p>
<p>2、对于结构上的问题，每一个回调点：例如受击方扣除x点血量这种event，应该是可以公用的，因此需要决定参数开放在哪的问题，但是旧buff系统关于这一块没有很好地解决</p>
<p>3、与UI的交互的问题，应该统一规定好与UI交互的位置，在移除buff图标的时候，不需要手动地调用一些方法</p>
<h3 id="新buff系统组成："><a href="#新buff系统组成：" class="headerlink" title="新buff系统组成："></a>新buff系统组成：</h3><p>首先是配置，配置方面采用luban配表游戏内so中间层显示的模式，,大体的数据结构不变。</p>
<h3 id="新buff系统系统拆解："><a href="#新buff系统系统拆解：" class="headerlink" title="新buff系统系统拆解："></a>新buff系统系统拆解：</h3><h4 id="层次结构："><a href="#层次结构：" class="headerlink" title="层次结构："></a>层次结构：</h4><p>主要分为luban层，SO层，和其他具体runtime时的数据层，配置的部分主要在luban层和SO层</p>
<h4 id="luban层配置"><a href="#luban层配置" class="headerlink" title="luban层配置"></a>luban层配置</h4><p>在luban的配置层，主要完成的工作是进行buffData的配置,也就是需要在excel表格中进行buffData的配置，在excel中需要进行如下配置</p>
<table>
<thead>
<tr>
<th>##var</th>
<th>id</th>
<th>name</th>
<th>buffIcon</th>
<th>tags</th>
<th>maxStack</th>
<th>buffRemoveStackUpdateEnum</th>
<th>buffUpdateEnum</th>
<th>duringCount</th>
<th>isPermanent</th>
<th>onCreateEvents</th>
<th>onRemoveEvents</th>
<th>onOtherRoundStartEvents</th>
<th>onThisRoundStartEvents</th>
<th>onOtherRoundEndEvents</th>
<th>onThisRoundEndEvents</th>
<th>onHitEvents</th>
<th>onBeHurtEvents</th>
<th>onKillEvents</th>
<th>onBeKilledEvents</th>
</tr>
</thead>
<tbody><tr>
<td>##Type</td>
<td>string</td>
<td>string</td>
<td>string</td>
<td>(list#sep&#x3D;|),string</td>
<td>int</td>
<td>BuffRemoveStackUpdateEnum</td>
<td>BuffUpdateEnum</td>
<td>int</td>
<td>bool</td>
<td>(list#sep&#x3D;|),string</td>
<td>(list#sep&#x3D;|),string</td>
<td>(list#sep&#x3D;|),string</td>
<td>(list#sep&#x3D;|),string</td>
<td>(list#sep&#x3D;|),string</td>
<td>(list#sep&#x3D;|),string</td>
<td>(list#sep&#x3D;|),string</td>
<td>(list#sep&#x3D;|),string</td>
<td>(list#sep&#x3D;|),string</td>
<td>(list#sep&#x3D;|),string</td>
</tr>
<tr>
<td>##</td>
<td>buff的唯一id</td>
<td>buff的名字</td>
<td>路径</td>
<td>buff的tag</td>
<td>buff的上限层数</td>
<td>buff移除的时候的模式</td>
<td>buff添加的模式</td>
<td>buff持续的回合数</td>
<td>是否永久</td>
<td>创建触发事件的类名列表</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>1</td>
<td>测试buff</td>
<td>“”</td>
<td></td>
<td>5</td>
<td>0</td>
<td>0</td>
<td>4</td>
<td>TRUE</td>
<td>HpEnhanceEvent</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>可以看到基本上在excel里面的配置就是之前buffData的部分配置，值得一提的是，这边的回调点配置是一个string的list,这边记录的是event的名字，每个event都是一个类，这边在具体生成的时候会反射转换成类</p>
<h4 id="unitySO层配置"><a href="#unitySO层配置" class="headerlink" title="unitySO层配置"></a>unitySO层配置</h4><p>在unitySO层的配置，主要时配置一些excel中配置不了的回调点event的参数，例如我有一个event指代的是扣血，不需要为了每个buff专门写每个的扣血event,因此需要开放出变量进行配置工作（下图是一个例子）</p>
<p><img src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/image-20240612224648289.png" alt="image-20240612224648289"></p>
<h4 id="具体工作流程："><a href="#具体工作流程：" class="headerlink" title="具体工作流程："></a>具体工作流程：</h4><p>1、先在excel表中配置buffData的一部分数据，通过luban的脚本生成json到unity的asset下（具体生成到什么文件夹看个人喜好）</p>
<p>2、在unity中通过buffEditor生成出buffDataSO以及相应的event</p>
<p>3、buffDataSO就是原本的buffData，需要再在实际运行的时候转成buffInfo</p>
<p>在引擎中生成出来的时候，会在指定的路径生成出相应buff的一整个文件夹，图示如下：</p>
<p><img src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/image-20240612230816691.png" alt="image-20240612230816691"></p>
]]></content>
      <tags>
        <tag>unity</tag>
        <tag>AI</tag>
      </tags>
  </entry>
</search>
